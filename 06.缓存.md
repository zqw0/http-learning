## 7 缓存
&emsp;&#9728;Web缓存是可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存时，如果本地有一缓存的副本，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存有以下优点：  
&#9728;缓存减少了冗余的数据传输，节省了你的网络费用。  
&#9728;缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快的加载页面。  
&#9728;缓存降低了对原始服务器的要求。服务器可以更快的响应，避免过载的情况。   
&#9728;缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。  
## 7.1 命中和未命中的  
&emsp;&#9728;用已有的副本为某些到达缓存的请求提供服务。这被称为**缓存命中**。其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为**缓存未命中**。
### 7.1.1 再验证
&emsp;&#9728;缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。缓存就会再次将副本标识为新鲜的，并将副本提供给客户端，这被称作再验证命中或缓慢命中。  
&emsp;HTTP为我们提供了几个用来对已缓存对象进行再验证的工作，但最常用的是If-Modified-Since首部。将这个首部添加到GET请求中去，就可以告诉服务器只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。这里列出了三种情况。服务器收到GET If-Modified-Since请求时会发生的情况。  
&#9728;再验证命中：如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP304 Not Modified响应。   
&#9728;再验证未命中：如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的，带有完整的内容的HTTP 200 OK响应。  
&#9728;对象被删除：如果服务器对象已经被删除，服务器就回送一个404 Not Found响应，缓存也会将其副本删除。    
### 7.1.2  缓存命中率与字节命中率  
&emsp;&#9728;缓存命中率是指，在一个访问来的时候。能再验证命中的几率。而由于文档的大小不同。所以就有了字节命中率的说法。就是说一个文档命中后，它的字节占总字节的多少。  
### 7.1.3 客户端如何区分是命中还是未命中
&emsp;&#9728;一般使用Date首部。将得到的日期和现在的时间相比较。如果得到的日期较早。那么说明极有可能是缓存得到的。  
## 7.2 代理缓存的层次结构  
&emsp;&#9728;在实际中，实现层次化的缓存是很有意义的，在这种结构中，在较小的缓存中未命中的请求会被导向较大的父缓存，由它来为剩下的流量提供服务。也就是说**一级缓存小一些，但更贴近请求的位置。当一级缓存无法命中时，就向二级缓存发起请求，二级缓存更大一些**。  
## 7.3 网状缓存、内容路由和对等缓存  
&emsp;&#9728;有些网络结构会构建复杂的网状缓存，而不是简单的缓存层次结构。**网状缓存中的代理缓存会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接和原始服务器进行通信。这种代理缓存会决定选择何种路由对内容进行访问。因此可将其称为内容路由**。网状缓存中为内容路由设计的缓存要完成下列所有功能。  
&#9728;根据URL在父缓存或原始服务器之间进行动态选择。  
&#9728;根据URL动态的选择一个特定的父缓存。  
&#9728;前往父缓存之前，在本地缓存中搜索已缓存的副本。  
&#9728;允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过他们的缓存。  
缓存之间这些更为复杂的关系允许不同的组织互为对等实体，将他们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为兄弟缓存。  
## 7.7 缓存的处理步骤 
（１）：接收——缓存从网络中读取抵达的请求报文。    
（２）：解析——缓存对报文进行解析，提取出URL和各种首部。   
（３）：查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本。并将其保存在本地。  
（４）：新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。  
（５）：创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。  
（６）：发送——缓存通过网络将响应发回给客户端。  
## 7.8 保持副本的新鲜  
&emsp;&#9728;为了保持副本的新鲜，HTTP提供了两个简单的机制。**文档过期和服务器再验证**。
### 7.8.1 文档过期  
&emsp;&#9728;通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加一个过期日期。如
```
Expres: Fri, 05 Jul 2002, 05:00:00 GMT
Cache-Control: max-age=484200
```
在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系——当然，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。在使用上，我们更倾向于使用Cache-Control。因为他是一个相对时间，而不是一个绝对时间。如果用Expres的话。就比较需要注意系统的时钟了。  
### 7.8.2 服务器再验证  
&emsp;&#9728;仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际区别；只是意味着到了要进行核对的时间了。这种情况被称为服务器再验证，说明缓存需要询问原始服务器文档是否发生了变化。   
&#9728;如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。    
&#9728;如果再验证显示内容没有发送变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就可以了。    
### 7.8.3 用条件方法进行再验证  
&emsp;&#9728;HTTP的条件方法可以高效的的实现再验证。HTTP允许缓存向原始服务器发送一个条件GET，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。  
&emsp;HTTP定义了５个请求首部。对缓存再验证来说最有用的２个首部是If-Modified-Since和If-None-Match。所有　的条件首部都以前缀If-开头。
```
If-Modified-Since:<date>        如果从指定日期之后文档被修改过了，就执行请求的方法。可以与Last-Modified服务器响应首部配合使用，只有在内容被修改后与已缓存版                                                               本有所不同的时候才去获取内容。
If-None-Match:<tags>              服务器可以为文档提供提供特殊的标签，而不是将其与最近修改的日期相匹配，这些标签就像序列号一样。如果已缓存标签与服务器文档中的                                                            标签有所不同，If-None-Match首部就会执行所请求的方法。
```
### 7.8.4 If-Modified-Since:Date再验证
&emsp;最常见的缓存验证首部是If-Modified-Since。它通常被称为IMS请求。**只有自某个日期之后资源发生了变化的时候，IMS请求才会指示服务器执行请求**。  
&#9728;如果自指定日期后，文档被修改了，If-Modified-Since条件就为真，通常GET就会成功执行。携带新首部的新文档就会被返回给缓存，新首部除了其他信息之外，还包括了一个新的过期日期。  
&#9728;如果自指定日期后，文档没有被修改过。条件就为假，会向客户端返回一个小的304 Not Modified响应报文。还会携带一个新的过期日期。  
### 7.8.5 If-None-Match:实体标签再验证
&emsp;有些情况下仅仅使用最后修改日期进行再验证是不够的。  
&#9728;有些文档可能会被周期性的重写，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。  
&#9728;有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内缓存都重装数据。  
&#9728;有些服务器无法准确的判断其页面的最后修改日期。  
&#9728;有些服务器提供的文档会在亚秒间隙发生变化，对于这些服务器来说，以一秒为粒度的修改日期可能就不够用了。  
&emsp;为了解决这个问题，HTTP允许用户使用实体标签ETag的版本标识符进行比较。**实体标签是附加到文档上的任意标签，他们可能是包含了文档的序列号或版本名，或者是文档内容的校验和及其其他指纹信息**。举例：
```
GET /announce.html HTTP/1.0
If-None-Match: "v2.6"

HTTP/1.0 304 Not Modified
Date: Wed, 03 Jul 2002 19:18:23 GMT
ETag: "v2.6"
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
```





























