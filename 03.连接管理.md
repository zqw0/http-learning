## ４.1 TCP连接
&emsp;&#9728;首先tcp/ip把网络分为４个层。应用层，传输层，网络层，数据链路层。而我们的http协议在应用层。所以我们要将http报文传给传输层的tcp，再由tcp传给网络层的ip...。所以我们再http报文传输时。就会使用tcp的三次握手。等tcp/ip协议
## 4.2 HTTP事务的时延
&#9728;原因１：客户端首先需要知道域名所对应的端口号。查询dns服务器得到端口号会浪费１０秒。前提是第一次访问这个域名。  
&#9728;原因２：TCP握手连接所造成的时延，单次握手时延在２秒，如果有很多个连接，这个时延会快速累积上去。  
&#9728;原因３：传输报文已经拿到从服务器得到的报文需要花费时间。  
## 4.2.1 time_wait累积与端口耗尽  
&emsp;&#9728;当我们用短连接时，从一个客户端一直发请求给一个服务器端。就有可能造成端口耗尽。当客户端断开连接时，因为time_wait所以要等待2msl。这时这个端口就处于不可用状态。所以我们连接时，就要换成其他端口。当端口全部使用完。这2msl还没有过去时，端口就耗尽了。我们再次发送请求就会出错。  
## 4.3 HTTP的连接处理  
概要此章主要介绍，Connection首部，以及常用的连接优化。
## 4.3.1 常被误解的Connection首部
&emsp;&#9728;HTTP的Connection首部字段中有一个由逗号分隔的连接标签列表。这些标签为此连接指定了一些不会传播到其他连接中去的选项。比如，用Connection close 来说明发送完下一条报文之后必须关闭的连接。  
&emsp;Connection首部可以承载３种不同的标签。  
&#9728;HTTP首部字段名，列出了只与此连接有关的首部。  
&#9728;任意标签值，用于描述此连接的非标准选项。  
&#9728;值close，说明操作完成之后需关闭这条持久化操作。  
## 4.3.2 串行事务处理时延  
&emsp;&#9728;当一个网页上需要建立多个tcp连接时。如果串行处理事务，那么就会增加极大的时延。所以我们提出几种连接优化。  
&#9728;并行连接：通过多条TCP连接发起并行的HTTP请求。  
&#9728;持久连接：重用tcp连接，以消除握手和断开连接时延。  
&#9728;管道化连接：通过共享的TCP连接发起并发的HTTP请求。  
## 4.4 并行连接
&emsp;&#9728;顾名思义，就是通过多线程，一起发起HTTP请求。优势很明显。一起发起，总比一条完成再发一条要快。但是**这时在带宽足够多的情况下。如果带宽不够多。并行连接中的每个连接反而会更慢，给人以都加载不出来的感觉**。所以我们一般一起开４个请求即可。  
## 4.5 持久连接
&emsp;&#9728;在事务处理结束之后仍然保持在打开状态的TCP连接被称为持久连接。非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。  
### 4.5.1 HTTP/1.0+ keep-alive
&emsp;&#9728;首先HTTP/1.0+并不是默认使用keep-alive，所以需要客户端去指定。客户端需要在Connection首部，加上keep-alive选项。在服务器同意之后，就会建立持久化连接。另外keep-alive还有可选字段。比如
```
Connection: Keep-Alive
Keep-alive: max=5, timeout=120
其中max=5,说明服务器最多还会为５个事务保持连接打开状态。或者将打开状态保持到连接空闲２分钟以后。但这些不是一定的保障。服务器可以随时关闭连接。
```
### 4.5.2 keep-alive和哑代理
&emsp;&#9728;我们已经知道了，建立keep-alive需要在Connection后面加上keep-alive。如果中间有一个代理会怎么样呢，我们来看看。有的老代理，只会进行盲转发。就是你发给它什么，它发出去什么。**当我们将带有持久化连接的报文发送给代理后，代理再次将这个报文发送给服务器，服务器收到可持久化请求后同意建立。于是转发给代理，代理再次发给客户端，建立可持久化连接。客户端和服务器都以为自己建立的可持久化连接。但是代理只支持短连接，只是盲转发可持久连接。它在一条事务完成后，就把这条事务关闭了。此时客户端还以为建立着可持久化连接，于是还向原来的连接发送。当然得不到任何回应。此时这个代理就变成了哑代理**。
### 4.5.3 插入proxy-Connection
&emsp;&#9728;我们分析哑代理出现的问题。就是盲转发，不分析报文，不处理报文。所以我们将Connection换成Proxy-Connection:keep-alive。如果是老代理，它盲转发。也无所谓，根本建立不了持久化连接。因为服务器不识别Proxy-Connection:keep-alive这个字段。但我们的新代理，在收到Proxy-Connection-alive时，就知道。你是想要建立持久化连接。那么这个聪明的代理。就会把Proxy-Connection:keep-alive替换成Connection:keep-alive。再转发给服务器，让服务器知道，要建立持久化连接。但是**这只能解决客户端与服务器之间有一个代理的情况。如果是这样一个顺序客户端－聪明代理－笨代理－服务器的顺序。就又会出现哑代理的情况**。
### 4.5.4 HTTP/1.1持久化连接
&emsp;&#9728;HTTP/1.1逐渐停止了对keep-alive连接支持，用一种名为持久连接(persistent connection)的改进型设计取代了它。他们目的相同，但后者工作机制更优一些。HTTP/1.1的持久化连接默认情况下是开启的，而1.0+是关闭的。
## 4.6 管道化连接
&emsp;&#9728;HTTP/1.1允许在持久化连接上可选的使用请求管道。这是相对于keep-alive连接的又一性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向另一端服务器时，第二条和第三条请求也可以开始发送了。相当于，多线程的持久化连接。























